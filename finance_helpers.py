"""
Various financial helpers to handle returns generated by monte carlo simulation
All returns inputs expected to be a list of floats
"""

import numpy as np

"""apply various option derivates to a set of returns"""
def apply_covered_call(returns, strike, premium):
    """
    Simulate writing a call

    If an element in returns exceeds strike, cap returns at strike
    Append premium (received) to all returns.

    Note on taxes:
    * This doesn't correctly handle taxes (yet) as call is short term cap gain,
    * but stock is long term cap loss.
    """
    return [(value + premium if value < strike else strike + premium)
            for value in returns]

def apply_protected_put(returns, strike, premium):
    """
    Simulate buying a put

    If an element is below strike, hold element at strike.
    Deduct premium paid from all returns.

    Taxes are generally correct here for long term/short term, because exercised puts
    have long term gain characteristics
    """
    return [(value - premium if value > strike else strike - premium)
            for value in returns]

def apply_collar(returns, min_strike, max_strike, premium=0):
    """
    Simulate holding a collar on equity.
    Premium represents premium paid
    """

    # only apply the premium once (put side)
    returns = apply_covered_call(returns, max_strike, premium=0)
    returns = apply_protected_put(returns, min_strike, premium)
    return returns


def blend_returns(returns1, returns2, blend_factor):
    """Blend returns1 and returns2 by blend_factor*returns1 + (1-blend_factor)*returns2"""
    assert 0<=blend_factor<=1
    return [ret1*blend_factor + ret2*(1-blend_factor) for ret1, ret2 in zip(returns1, returns2)]


"""
Various math operations
"""

def average_log_return(returns):
    """
    Return the average log return.

    EXP(gbm(1) = exp(u), where u is the log expectation
    We therefore arithmetically everage returns, and then log them
    """
    return np.log(np.mean(returns))

def log_returns(returns):
    return np.log(returns)

def volatility_of_returns(returns):
    """return volatility of returns"""
    lg_rets = log_returns(returns)
    return np.std(lg_rets)

RISK_FREE_RATE = 0.0221 * (0.5) # tax adjusted
def sharpe_ratio(returns, risk_free_rate = RISK_FREE_RATE):
    """calculate (average) sharpe ratio.
    risk free rate uses 30 day t-bill ratio
    """
    return (average_log_return(returns) - risk_free_rate)/volatility_of_returns(returns)